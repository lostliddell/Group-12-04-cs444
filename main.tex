\documentclass[draftclsnofoot,onecolumn,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[letterpaper, portrait, margin=0.75in]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{titling}
\usepackage{array}
\title{CS 444 Homework 1}
\author{Alexander Uldricks}
\date{March 21, 2017}

\begin{document}

    \renewcommand\thesection{\arabic{section}}
    \renewcommand\thesubsection{\arabic{section}.\arabic{subsection}}
    \renewcommand\thesubsubsection{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}}
    \begin{flushleft}
    Group 12-04
    \end{flushleft}
    \begin{flushleft}
    Homework 1
    \end{flushleft}
    \begin{flushleft}
    Alex Uldricks
    \end{flushleft}
    \begin{flushleft}
    Andrew Peterkort
    \end{flushleft}    
    \begin{flushleft}
    Minsung Choi
    \end{flushleft}
    % LOG OF KERNEL COMMANDS
    \section{Kernel Assignment Log}
    \begin{flushleft}
    ssh -l peterkoa flip.engr.oregonstate.edu\
    \end{flushleft}
    \begin{flushleft}
    ssh os-class\
    \end{flushleft}
    \begin{flushleft}
    cd /\
    \end{flushleft}
    \begin{flushleft}
    cd scratch/spring2017\
    \end{flushleft}
    \begin{flushleft}
    mkdir 12-04\
    \end{flushleft}
    \begin{flushleft}
    cd 12-04\
    \end{flushleft}
    \begin{flushleft}
    git clone git://git.yoctoproject.org/linux-yocto-3.14\
    \end{flushleft}
    \begin{flushleft}
    cd linux-yocto-3.14\
    \end{flushleft}
    \begin{flushleft}
    git checkout v3.14.26\
    \end{flushleft}
    \begin{flushleft}
    source /scratch/opt/environment-setup-i586-poky-linux.csh\
    \end{flushleft}
    \begin{flushleft}
    cp /scratch/spring2017/files/config-3.14.26-yocto-qemu.config\
    \end{flushleft}
    \begin{flushleft}
    menuconfig\
    \end{flushleft}
    \begin{flushleft}
    /LOCALVERSION\
    \end{flushleft}
    \begin{flushleft}
    1 -12-04-hw1\
    \end{flushleft}
    \begin{flushleft}
    make -j4\
    \end{flushleft}
    \begin{flushleft}
    cd ..\
    \end{flushleft}
    \begin{flushleft}
    gdb\
    \end{flushleft}
    \begin{flushleft}
    cd scratch/spring2017/12-04\
    \end{flushleft}
    \begin{flushleft}
    source /scratch/opt/environment-setup-i586-poky-linux.csh\
    \end{flushleft}
    \begin{flushleft}
    cp /scratch/spring2017/files/bzImage-qemux86.bin .\
    \end{flushleft}
    \begin{flushleft}
    cp /scratch/spring2017/files/core-image-lsb-sdk-qemux86.ext3 .\
    \end{flushleft}
    \begin{flushleft}
    \cf2 \expnd0\expndtw0\kerning0
    \end{flushleft}
    \begin{flushleft}
    qemu-system-i386 -gdb tcp::5624 -S -nographic -kernel bzImage-qemux86.bin -drive file=core-image-lsb-sdk-qemux86.ext3,if=virtio -enable-kvm -net none -usb -localtime --no-reboot --append "root=/dev/vda rw console=ttyS0 debug"\
    \end{flushleft}
    \begin{flushleft}
    continue\
    \end{flushleft}
    \begin{flushleft}
    root\
    \end{flushleft}
    \begin{flushleft}
    uname -a\
    \end{flushleft}
    \begin{flushleft}
    reboot\
    \end{flushleft}
    \begin{flushleft}
    qemu-system-i386 -gdb tcp::5624 -S -nographic -kernel linux-yocto-3.14/arch/x86/boot/bzImage\'a0 -drive file=core-image-lsb-sdk-qemux86.ext3,if=virtio -enable-kvm -net none -usb -localtime --no-reboot --append "root=/dev/vda rw console=ttyS0 debug"\
    \end{flushleft}
    \begin{flushleft}
    continue\
    \end{flushleft}
    \begin{flushleft}
    root\
    \end{flushleft}
    \begin{flushleft}
    uname -a\
    \end{flushleft}
    \begin{flushleft}
    reboot\
\end{flushleft}
        
    % QEMU EXPLANATION
    \section{Qemu Flag Explanations}
    \begin{flushleft}
    -gdb = wait for gdb connection to the device using tcp on port 5624\
    \end{flushleft}
    \begin{flushleft}
-S = does not start CPU at start up\
    \end{flushleft}
    \begin{flushleft}
-nographic = disables graphical GUI\
    \end{flushleft}
    \begin{flushleft}
-kernel = switches the image boot kernel to the bzimage listed afterwards\
    \end{flushleft}
    \begin{flushleft}
-drive = defines a new drive file\
    \end{flushleft}
    \begin{flushleft}
-enable-kvm = enables the linux kernel virtual machine support which helps with x86 configurations for linux virtualization\
    \end{flushleft}
    \begin{flushleft}
-net = sets initialization for network interface card to set up network. when set to none, not network card is initialized\
    \end{flushleft}
    \begin{flushleft}
-usb = enables usb driver\
    \end{flushleft}
    \begin{flushleft}
-localtime = initialized local time in kernel not UTC time\
    \end{flushleft}
    \begin{flushleft}
'97no-reboot sets the reboot command to turn the kernel off instead of reboot\
    \end{flushleft}
    \begin{flushleft}
'97append = the following command gets ientered into the kernel command line\
    \end{flushleft}
    % CONCURRENCY WRITEUP
    \section{Concurrency Solution}
        \begin{flushleft}
        In order to complete this concurrency assignment, we needed to use pthreads. Since C has a pthread library, we used this in order to use mutex. Mutex allows us  to multithread, which is required for this assignment. In this assignment, we have two types of threads. The first is a producer thread, which adds object to the buffer. The second is the consumer thread, which reads as well as deletes objects from the buffer. Using mutex, we locked and unlocked access to the buffer between each thread so that multiple threads are not trying to access the buffer at the same time. Using this, we implemented the producer and consumer thread functions. In order to keep track of the buffer values as well as shared values that both threads may use, we used a global struct. Since we are using mutex, the global variables can only be accessed by 1 thread at a time. Since there are times that the threads are ideal, we used the mutex condition functions in order to wake up the threads that were waiting. With all that in place, the threads worked as intended. The last problem that needed to be solved was the random number generated. We implemented this by following the Mesenne Twister instructions and created the genrand function. With that, we were able to solve the producer consumer problem.
        \end{flushleft}
        
    % CONCURRENCY QUESTIONS
    \section{Concurrency Questions}
        \begin{flushleft}
        1. The main point of the assignment is to understand concurrency in its most basic form because it should be, as the assignment states, an elementary subject that we easily understand. Because processors donâ€™t individually become much faster or larger, implementing multiple threads in the future will become the primary way to increase program performance making it an extremely valuable skill for the next generation of programmers.
        \end{flushleft}
        
        \begin{flushleft}
    	2. While approaching the problem we found that having threads that looped through the consume and produce functions was a lot easier than making individual threads and then deleting them afterwards. Also, dividing the problem into smaller problems and giving them out to the members of our group allowed us to work more efficiently while being away from each other. For example, while someone was figuring out the random number generator, others worked on the parallelization. For the design we decided to use the create thread function that also launched that thread into a funtion of our own creation to allow for individual threads of both consumer and producer type.
    	\end{flushleft}
	
	    \begin{flushleft}
    	3. Lots of testing of each individual part was used with printf() statements along the way to test intermediate value inside the code for error. Before random numbers were included they were tested to see if hey worked correctly and vise versa for all the other individual modules of the code. Using incremental development kept our code mostly bug free for most the programming.
    	\end{flushleft}
    	
        \begin{flushleft}
    	4. In total, we learned about the variety of potential problems that parallelization can create. We had two threads trying to access the same variable at the same time and two threads trying to access the same function at the same time. Most of the conflicting issues were solved with mutexing and condition flags throughout our code.

        \end{flushleft}
            
    %WORK LOG
    \section{Work Log}
        \begin{flushleft}
        The group met on Wednesday, March 12 after recitation to complete the kernel portion of the assignment. The next time we met was Monday of the next week, to start talking about solutions to the concurrency assignment and to make sure we completed the kernel assignment correctly. Our last meeting was a lengthy period spent in the library on Friday, March 21, where we worked together on the writeup and the concurrency assignment proper for several hours. 
        \end{flushleft}
            
\end{document}


